#!/usr/bin/env dart

import 'dart:io';
import 'dart:convert';

Future<void> main(List<String> arguments) async {
  print('\x1B[36mü™∂ Plumer CLI - Flutter scaffolding made easy\x1B[0m');

  if (arguments.isEmpty || arguments[0] == 'help' || arguments[0] == '--help' || arguments[0] == '-h') {
    _showHelp();
    exit(0);
  }

  if (!await _isFlutterProject()) {
    print('\x1B[31m‚ùå This is not a Flutter project. Exiting.\x1B[0m');
    exit(1);
  }

  final packageName = await _getPackageName();
  final command = arguments[0];

  if (command == 'init') {
    await _initProject();
  } else if (command.startsWith('install:')) {
    final subCommand = command.split(':');
    if (subCommand.length == 2 && subCommand[1] == 'widget') {
      if (arguments.length < 2) {
        print('\x1B[31m‚ùå Missing required widget name for "install:widget".\x1B[0m');
        print('Example: plumer install:widget slider');
        print('         plumer install:widget slider lib/components');
        exit(1);
      }
      final widgetName = arguments[1];
      final customPath = arguments.length > 2 ? arguments[2] : null;
      await _installWidget(widgetName, customPath);
    } else {
      print('\x1B[31m‚ùå Unknown install command: $command\x1B[0m');
      print('Available: install:widget');
    }
  } else {
    if (arguments.length < 2) {
      print('\x1B[31m‚ùå Missing required path argument for "$command".\x1B[0m');
      print('Example: plumer $command Booking/Flight');
      exit(1);
    }

    final rawPath = arguments[1];
    final pathParts = rawPath.split('/');
    final classBaseName = _toPascalCase(pathParts.last);
    final folderPath = pathParts.length > 1
        ? pathParts.sublist(0, pathParts.length - 1).map(_toSnakeCase).join('/')
        : '';
    final snakeName = _toSnakeCase(pathParts.last);

    switch (command) {
      case 'make:controller':
        await _createController(folderPath, classBaseName, snakeName);
        break;
      case 'make:binding':
        await _createBinding(folderPath, classBaseName, snakeName, packageName);
        break;
      case 'make:screen':
        await _createScreen(folderPath, classBaseName, snakeName, packageName);
        break;
      case 'make:page':
        await _makePage(folderPath, classBaseName, snakeName, packageName);
        break;
      default:
        print('\x1B[31m‚ùå Unknown command: $command\x1B[0m');
        _showHelp();
    }
  }
}

Future<void> _initProject() async {
  final pubspec = File('pubspec.yaml');
  if (!pubspec.existsSync()) {
    print('\x1B[31m‚ùå Error: Not a Flutter project. pubspec.yaml not found.\x1B[0m');
    exit(1);
  }

  print('\x1B[36müöÄ Initializing Flutter project with GetX and Dio...\x1B[0m');

  // Install GetX and Dio
  await Process.run('dart', ['pub', 'add', 'get']);
  await Process.run('dart', ['pub', 'add', 'dio']);

  print('\x1B[32m‚úÖ Installed GetX and Dio.\x1B[0m');

  // Create folder structure
  final dirs = [
    'lib/config',
    'lib/controllers',
    'lib/bindings',
    'lib/models',
    'lib/screens',
    'lib/widgets',
  ];
  for (var dir in dirs) {
    await Directory(dir).create(recursive: true);
  }
  print('\x1B[32m‚úÖ Created recommended folder structure.\x1B[0m');

  // Create app_colors.dart with theme support
  final appColorsContent = '''
import 'package:flutter/material.dart';

class AppColors {
  // Light Theme Colors
  static const Color lightPrimary = Color(0xFF6366F1); // Modern indigo
  static const Color lightSecondary = Color(0xFF8B5CF6); // Purple
  static const Color lightAccent = Color(0xFF10B981); // Emerald
  static const Color lightBackground = Color(0xFFFAFAFA);
  static const Color lightSurface = Colors.white;
  static const Color lightOnPrimary = Colors.white;
  static const Color lightOnSecondary = Colors.white;
  static const Color lightOnBackground = Color(0xFF1F2937);
  static const Color lightOnSurface = Color(0xFF1F2937);
  
  // Dark Theme Colors
  static const Color darkPrimary = Color(0xFF818CF8); // Light indigo
  static const Color darkSecondary = Color(0xFFA78BFA); // Light purple  
  static const Color darkAccent = Color(0xFF34D399); // Light emerald
  static const Color darkBackground = Color(0xFF0F172A); // Dark slate
  static const Color darkSurface = Color(0xFF1E293B); // Medium slate
  static const Color darkOnPrimary = Color(0xFF0F172A);
  static const Color darkOnSecondary = Color(0xFF0F172A);
  static const Color darkOnBackground = Color(0xFFF8FAFC);
  static const Color darkOnSurface = Color(0xFFF8FAFC);

  // Legacy colors for backward compatibility
  static const Color primary = lightPrimary;
  static const Color accent = lightAccent;
  static const Color appBarColor = Colors.white;
  static const Color appBarBackground = lightPrimary;
}
''';
  await File('lib/config/app_colors.dart').writeAsString(appColorsContent);
  print('\x1B[32m‚úÖ Created lib/config/app_colors.dart\x1B[0m');

  // Create app_routes.dart
  final appRoutesContent = '''
import 'package:get/get.dart';

class AppRoutes {
  static final routes = <GetPage>[];
}
''';
  await File('lib/config/app_routes.dart').writeAsString(appRoutesContent);
  print('\x1B[32m‚úÖ Created lib/config/app_routes.dart\x1B[0m');

  // Create app_theme.dart
  final appThemeContent = '''
import 'package:flutter/material.dart';
import 'app_colors.dart';

class AppTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      primarySwatch: _createMaterialColor(AppColors.lightPrimary),
      primaryColor: AppColors.lightPrimary,
      colorScheme: const ColorScheme.light(
        primary: AppColors.lightPrimary,
        secondary: AppColors.lightSecondary,
        tertiary: AppColors.lightAccent,
        background: AppColors.lightBackground,
        surface: AppColors.lightSurface,
        onPrimary: AppColors.lightOnPrimary,
        onSecondary: AppColors.lightOnSecondary,
        onBackground: AppColors.lightOnBackground,
        onSurface: AppColors.lightOnSurface,
      ),
      scaffoldBackgroundColor: AppColors.lightBackground,
      appBarTheme: const AppBarTheme(
        backgroundColor: AppColors.lightPrimary,
        foregroundColor: AppColors.lightOnPrimary,
        elevation: 0,
        centerTitle: true,
      ),
      cardTheme: const CardTheme(
        color: AppColors.lightSurface,
        elevation: 2,
        margin: EdgeInsets.all(8),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppColors.lightPrimary,
          foregroundColor: AppColors.lightOnPrimary,
          elevation: 2,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: AppColors.lightPrimary),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: AppColors.lightPrimary, width: 2),
        ),
      ),
      fontFamily: 'Roboto',
    );
  }

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      primarySwatch: _createMaterialColor(AppColors.darkPrimary),
      primaryColor: AppColors.darkPrimary,
      colorScheme: const ColorScheme.dark(
        primary: AppColors.darkPrimary,
        secondary: AppColors.darkSecondary,
        tertiary: AppColors.darkAccent,
        background: AppColors.darkBackground,
        surface: AppColors.darkSurface,
        onPrimary: AppColors.darkOnPrimary,
        onSecondary: AppColors.darkOnSecondary,
        onBackground: AppColors.darkOnBackground,
        onSurface: AppColors.darkOnSurface,
      ),
      scaffoldBackgroundColor: AppColors.darkBackground,
      appBarTheme: const AppBarTheme(
        backgroundColor: AppColors.darkSurface,
        foregroundColor: AppColors.darkOnSurface,
        elevation: 0,
        centerTitle: true,
      ),
      cardTheme: const CardTheme(
        color: AppColors.darkSurface,
        elevation: 4,
        margin: EdgeInsets.all(8),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppColors.darkPrimary,
          foregroundColor: AppColors.darkOnPrimary,
          elevation: 2,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: AppColors.darkPrimary),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: AppColors.darkPrimary, width: 2),
        ),
      ),
      fontFamily: 'Roboto',
    );
  }

  static MaterialColor _createMaterialColor(Color color) {
    List strengths = <double>[.05];
    final swatch = <int, Color>{};
    final int r = color.red, g = color.green, b = color.blue;

    for (int i = 1; i < 10; i++) {
      strengths.add(0.1 * i);
    }

    for (var strength in strengths) {
      final double ds = 0.5 - strength;
      swatch[(strength * 1000).round()] = Color.fromRGBO(
        r + ((ds < 0 ? r : (255 - r)) * ds).round(),
        g + ((ds < 0 ? g : (255 - g)) * ds).round(),
        b + ((ds < 0 ? b : (255 - b)) * ds).round(),
        1,
      );
    }

    return MaterialColor(color.value, swatch);
  }
}
''';
  await File('lib/config/app_theme.dart').writeAsString(appThemeContent);
  print('\x1B[32m‚úÖ Created lib/config/app_theme.dart\x1B[0m');

  // Create MainPage
  final mainPageContent = '''
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class MainPage extends StatelessWidget {
  const MainPage({super.key});

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Welcome to Plumer'),
        actions: [
          IconButton(
            icon: Icon(isDark ? Icons.light_mode : Icons.dark_mode),
            onPressed: () {
              Get.changeThemeMode(
                isDark ? ThemeMode.light : ThemeMode.dark,
              );
            },
            tooltip: isDark ? 'Switch to Light Mode' : 'Switch to Dark Mode',
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.flutter_dash,
              size: 80,
              color: Theme.of(context).colorScheme.primary,
            ),
            const SizedBox(height: 24),
            Text(
              'Plumer CLI',
              style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                fontWeight: FontWeight.bold,
                color: Theme.of(context).colorScheme.primary,
              ),
            ),
            const SizedBox(height: 16),
            Text(
              'Your Flutter project has been initialized successfully!',
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                color: Theme.of(context).colorScheme.onBackground,
              ),
            ),
            const SizedBox(height: 32),
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  children: [
                    Icon(
                      Icons.palette,
                      size: 40,
                      color: Theme.of(context).colorScheme.secondary,
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Theme Support',
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Your app now supports both light and dark themes. Toggle between them using the button in the app bar!',
                      textAlign: TextAlign.center,
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 24),
            ElevatedButton.icon(
              onPressed: () {
                Get.snackbar(
                  'Welcome!',
                  'Start building your amazing Flutter app with Plumer CLI',
                  snackPosition: SnackPosition.BOTTOM,
                  backgroundColor: Theme.of(context).colorScheme.primary,
                  colorText: Theme.of(context).colorScheme.onPrimary,
                );
              },
              icon: const Icon(Icons.rocket_launch),
              label: const Text('Get Started'),
            ),
          ],
        ),
      ),
    );
  }
}
''';
  await File('lib/screens/main_page.dart').writeAsString(mainPageContent);
  print('\x1B[32m‚úÖ Created lib/screens/main_page.dart\x1B[0m');

  // Replace main.dart
  final mainDartContent = '''
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'config/app_theme.dart';
import 'config/app_routes.dart';
import 'screens/main_page.dart';

void main() {
  runApp(const PlumerApp());
}

class PlumerApp extends StatelessWidget {
  const PlumerApp({super.key});

  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Plumer App',
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: ThemeMode.system, // Automatically switches based on system preference
      initialRoute: '/',
      getPages: [
        GetPage(name: '/', page: () => const MainPage()),
        ...AppRoutes.routes,
      ],
    );
  }
}
''';
  await File('lib/main.dart').writeAsString(mainDartContent);
  print('\x1B[32m‚úÖ Overwrote lib/main.dart with Plumer starter template.\x1B[0m');

  print('\x1B[36müéâ Plumer initialization complete! Run your app with:\n   flutter run\x1B[0m');
}

Future<void> _installWidget(String widgetName, String? customPath) async {
  print('\x1B[36müì¶ Installing widget: $widgetName\x1B[0m');
  
  // Determine the target folder
  final targetFolder = customPath ?? 'lib/widgets';
  
  // Create target directory if it doesn't exist
  final targetDir = Directory(targetFolder);
  if (!targetDir.existsSync()) {
    await targetDir.create(recursive: true);
    print('\x1B[32m‚úÖ Created directory: $targetFolder\x1B[0m');
  }
  
  // Construct the GitHub raw file URL
  final githubUrl = 'https://raw.githubusercontent.com/dennokorir/plumer/main/widgets/$widgetName.dart';
  final targetFile = File('$targetFolder/$widgetName.dart');
  
  // Check if file already exists
  if (targetFile.existsSync()) {
    print('\x1B[33m‚ö†Ô∏è  Widget $widgetName.dart already exists in $targetFolder\x1B[0m');
    print('Do you want to overwrite it? (y/N): ');
    final response = stdin.readLineSync()?.toLowerCase();
    if (response != 'y' && response != 'yes') {
      print('\x1B[36müìã Installation cancelled.\x1B[0m');
      return;
    }
  }
  
  try {
    print('\x1B[36m‚¨áÔ∏è  Downloading from GitHub...\x1B[0m');
    
    // Download the widget file from GitHub
    final result = await Process.run('curl', [
      '-s',
      '-f',
      '-L',
      githubUrl,
    ]);
    
    if (result.exitCode == 0 && result.stdout.toString().trim().isNotEmpty) {
      final widgetContent = result.stdout.toString();
      
      // Check if we got a valid Dart file (basic validation)
      if (!widgetContent.contains('class') || widgetContent.contains('404: Not Found')) {
        print('\x1B[31m‚ùå Widget "$widgetName" not found in the repository.\x1B[0m');
        print('Available widgets: slider, button, card, input, dialog');
        print('Or check: https://github.com/dennokorir/plumer/tree/main/widgets');
        return;
      }
      
      // Write the file
      await targetFile.writeAsString(widgetContent);
      
      print('\x1B[32m‚úÖ Successfully installed $widgetName.dart to $targetFolder\x1B[0m');
      
      // Show usage instructions
      print('\x1B[36müí° Usage instructions:\x1B[0m');
      print('   1. Import the widget in your screen/page:');
      print('      import \'package:your_app/$targetFolder/$widgetName.dart\';');
      print('   2. Use it in your widget tree:');
      print('      ${_toPascalCase(widgetName)}()');
      
    } else {
      print('\x1B[31m‚ùå Failed to download widget from GitHub.\x1B[0m');
      print('Error: ${result.stderr}');
      print('Please check your internet connection and try again.');
    }
    
  } catch (e) {
    print('\x1B[31m‚ùå Error downloading widget: $e\x1B[0m');
    print('Please ensure curl is installed and you have internet connectivity.');
  }
}

void _showHelp() {
  print('\x1B[36mü™∂ Plumer CLI - Available Commands:\x1B[0m');
  print('');
  print('\x1B[33mProject Setup:\x1B[0m');
  print('  init                     Initialize project with GetX, themes, and structure');
  print('');
  print('\x1B[33mCode Generation:\x1B[0m');
  print('  make:controller [path]   Generate a GetX controller');
  print('  make:binding [path]      Generate a GetX binding');
  print('  make:screen [path]       Generate a Flutter screen/page');
  print('  make:page [path]         Generate complete page (controller + binding + screen + route)');
  print('');
  print('\x1B[33mWidget Installation:\x1B[0m');
  print('  install:widget [name]              Install widget to lib/widgets/');
  print('  install:widget [name] [folder]     Install widget to custom folder');
  print('');
  print('\x1B[33mExamples:\x1B[0m');
  print('  plumer init');
  print('  plumer make:page User/Profile');
  print('  plumer make:controller Auth/Login');
  print('  plumer install:widget slider');
  print('  plumer install:widget button lib/components');
  print('');
  print('\x1B[33mFor more information, visit:\x1B[0m https://github.com/dennokorir/plumer');
}

Future<bool> _isFlutterProject() async {
  final pubspec = File('pubspec.yaml');
  if (!pubspec.existsSync()) return false;
  final content = await pubspec.readAsString();
  return content.contains('flutter:');
}

Future<String> _getPackageName() async {
  final pubspec = File('pubspec.yaml');
  if (!pubspec.existsSync()) {
    print('\x1B[31m‚ùå pubspec.yaml not found. Exiting.\x1B[0m');
    exit(1);
  }
  final content = await pubspec.readAsLines();
  for (final line in content) {
    final trimmed = line.trim();
    if (trimmed.startsWith('name:')) {
      final name = trimmed.substring(5).trim();
      if (name.isNotEmpty) return name;
    }
  }
  print('\x1B[31m‚ùå Could not find project name in pubspec.yaml. Exiting.\x1B[0m');
  exit(1);
}

Future<void> _makePage(String folder, String pascal, String snake, String packageName) async {
  final controllerPath = 'lib/controllers${folder.isNotEmpty ? '/$folder' : ''}/${snake}_controller.dart';
  final bindingPath = 'lib/bindings${folder.isNotEmpty ? '/$folder' : ''}/${snake}_binding.dart';
  final screenPath = 'lib/screens${folder.isNotEmpty ? '/$folder' : ''}/${snake}_screen.dart';

  final routeName = "/${folder.isNotEmpty ? folder + '/' : ''}${snake}".replaceAll('_', '');
  final routeSignature = "GetPage(name: '$routeName',";

  final appRoutesFile = File('lib/config/app_routes.dart');
  if (!appRoutesFile.existsSync()) {
    print('\x1B[31m‚ùå lib/config/app_routes.dart not found. Cannot update routes.\x1B[0m');
    exit(1);
  }

  final appRoutesContent = await appRoutesFile.readAsString();

  final conflicts = <String>[];
  if (File(controllerPath).existsSync()) conflicts.add(controllerPath);
  if (File(bindingPath).existsSync()) conflicts.add(bindingPath);
  if (File(screenPath).existsSync()) conflicts.add(screenPath);
  if (appRoutesContent.contains(routeSignature)) conflicts.add('Route already exists in app_routes.dart');

  if (conflicts.isNotEmpty) {
    print('\x1B[31m‚ùå Cannot create page because the following already exist:\x1B[0m');
    for (final c in conflicts) {
      print(' - $c');
    }
    print('\x1B[31mAborting and reverting changes.\x1B[0m');
    exit(1);
  }

  await _createController(folder, pascal, snake);
  await _createBinding(folder, pascal, snake, packageName);
  await _createScreen(folder, pascal, snake, packageName);
  await _updateAppRoutes(folder, pascal, snake, packageName);

  print('\x1B[32m‚úÖ Page created and registered in routes for "$folder/$pascal".\x1B[0m');
}

Future<void> _createController(String folder, String pascal, String snake) async {
  final dir = 'lib/controllers${folder.isNotEmpty ? '/$folder' : ''}';
  final file = File('$dir/${snake}_controller.dart');
  await file.create(recursive: true);
  await file.writeAsString('''
import 'package:get/get.dart';

class ${pascal}Controller extends GetxController {

}
''');
  print('\x1B[32m‚úÖ Controller created: ${file.path}\x1B[0m');
}

Future<void> _createBinding(String folder, String pascal, String snake, String packageName) async {
  final dir = 'lib/bindings${folder.isNotEmpty ? '/$folder' : ''}';
  final file = File('$dir/${snake}_binding.dart');
  await file.create(recursive: true);
  final importPath = 'package:$packageName/controllers${folder.isNotEmpty ? '/$folder' : ''}/${snake}_controller.dart';
  await file.writeAsString('''
import 'package:get/get.dart';
import '$importPath';

class ${pascal}Binding extends Bindings {
  @override
  void dependencies() {
    Get.lazyPut<${pascal}Controller>(() => ${pascal}Controller());
  }
}
''');
  print('\x1B[32m‚úÖ Binding created: ${file.path}\x1B[0m');
}

Future<void> _createScreen(String folder, String pascal, String snake, String packageName) async {
  final dir = 'lib/screens${folder.isNotEmpty ? '/$folder' : ''}';
  final file = File('$dir/${snake}_screen.dart');
  await file.create(recursive: true);
  final importPath = 'package:$packageName/controllers${folder.isNotEmpty ? '/$folder' : ''}/${snake}_controller.dart';
  await file.writeAsString('''
import 'package:get/get.dart';
import 'package:flutter/material.dart';
import 'package:$packageName/config/app_colors.dart';
import '$importPath';

class ${pascal}Screen extends GetView<${pascal}Controller> {
  const ${pascal}Screen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('${_splitPascalCase(pascal)}'),
        backgroundColor: AppColors.appBarBackground,
        foregroundColor: AppColors.appBarColor,
      ),
      body: const Center(
        child: Text(
          '${_splitPascalCase(pascal)} Screen',
          style: TextStyle(color: AppColors.primary, fontSize: 24),
        ),
      ),
    );
  }
}
''');
  print('\x1B[32m‚úÖ Screen created: ${file.path}\x1B[0m');
}

Future<void> _updateAppRoutes(
  String folder,
  String pascal,
  String snake,
  String packageName,
) async {
  final appRoutesFile = File('lib/config/app_routes.dart');

  if (!appRoutesFile.existsSync()) {
    print('\x1B[31m‚ùå lib/config/app_routes.dart not found.\x1B[0m');
    exit(1);
  }

  var content = await appRoutesFile.readAsString();

  final importBinding =
      "import 'package:$packageName/bindings${folder.isNotEmpty ? '/$folder' : ''}/${snake}_binding.dart';";
  final importScreen =
      "import 'package:$packageName/screens${folder.isNotEmpty ? '/$folder' : ''}/${snake}_screen.dart';";

  final routeName =
      "/${folder.isNotEmpty ? folder + '/' : ''}${snake}".replaceAll('_', '');
  final pageRegistration =
      "GetPage(name: '$routeName', page: () => const ${pascal}Screen(), binding: ${pascal}Binding()),";

  // Insert imports at top if not present
  if (!content.contains(importBinding)) {
    // Put AFTER the last import OR at top
    final importRegex = RegExp(r"(import .+;)");
    final matches = importRegex.allMatches(content).toList();
    if (matches.isNotEmpty) {
      final lastImport = matches.last;
      content = content.replaceRange(
        lastImport.end,
        lastImport.end,
        '\n$importBinding',
      );
    } else {
      content = '$importBinding\n$content';
    }
  }

  if (!content.contains(importScreen)) {
    final importRegex = RegExp(r"(import .+;)");
    final matches = importRegex.allMatches(content).toList();
    if (matches.isNotEmpty) {
      final lastImport = matches.last;
      content = content.replaceRange(
        lastImport.end,
        lastImport.end,
        '\n$importScreen',
      );
    } else {
      content = '$importScreen\n$content';
    }
  }

  // Flexible route list regex for [] or <GetPage>[]
  final routesRegex =
      RegExp(r'static final routes\s*=\s*(<GetPage>)?\[(.*?)\];', dotAll: true);
  final match = routesRegex.firstMatch(content);

  if (match != null) {
    final currentRoutes = match.group(2)?.trim() ?? '';
    final updatedRoutes = (currentRoutes.isEmpty)
        ? '  $pageRegistration'
        : '$currentRoutes\n    $pageRegistration';

    final newRoutes = match.group(1) != null
        ? 'static final routes = <GetPage>[\n$updatedRoutes\n  ];'
        : 'static final routes = [\n$updatedRoutes\n  ];';

    content = content.replaceFirst(routesRegex, newRoutes);

    await appRoutesFile.writeAsString(content);
    print(
        '\x1B[32m‚úÖ Route for "$routeName" added to lib/config/app_routes.dart\x1B[0m');
  } else {
    print(
        '\x1B[31m‚ùå Could not locate routes list in app_routes.dart. Please ensure it uses: static final routes = []; or static final routes = <GetPage>[];\x1B[0m');
    exit(1);
  }
}

String _toSnakeCase(String input) {
  return input.replaceAllMapped(
      RegExp(r'([a-z0-9])([A-Z])'), (Match m) => '${m[1]}_${m[2]}').toLowerCase();
}

String _toPascalCase(String input) {
  return input
      .split(RegExp(r'[_\-\s]'))
      .where((part) => part.isNotEmpty)
      .map((part) => part[0].toUpperCase() + part.substring(1))
      .join();
}

String _splitPascalCase(String input) {
  return input.replaceAllMapped(RegExp(r'([a-z])([A-Z])'), (m) => '${m[1]} ${m[2]}');
}


