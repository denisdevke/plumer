#!/usr/bin/env dart

import 'dart:io';
import 'dart:convert';

Future<void> main(List<String> arguments) async {
  print('\x1B[36mü™∂ Plumer CLI - Flutter scaffolding made easy\x1B[0m');

  if (arguments.isEmpty || arguments[0] == 'help' || arguments[0] == '--help' || arguments[0] == '-h') {
    _showHelp();
    exit(0);
  }

  if (!await _isFlutterProject()) {
    print('\x1B[31m‚ùå This is not a Flutter project. Exiting.\x1B[0m');
    exit(1);
  }

  final packageName = await _getPackageName();
  final command = arguments[0];

  if (command == 'init') {
    await _initProject();
  } else if (command.startsWith('install:')) {
    final subCommand = command.split(':');
    if (subCommand.length == 2 && subCommand[1] == 'widget') {
      if (arguments.length < 2) {
        print('\x1B[31m‚ùå Missing required widget name for "install:widget".\x1B[0m');
        print('Example: plumer install:widget slider');
        print('         plumer install:widget slider lib/components');
        exit(1);
      }
      final widgetName = arguments[1];
      final customPath = arguments.length > 2 ? arguments[2] : null;
      await _installWidget(widgetName, customPath);
    } else {
      print('\x1B[31m‚ùå Unknown install command: $command\x1B[0m');
      print('Available: install:widget');
    }
  } else {
    if (arguments.length < 2) {
      print('\x1B[31m‚ùå Missing required path argument for "$command".\x1B[0m');
      print('Example: plumer $command Booking/Flight');
      exit(1);
    }

    final rawPath = arguments[1];
    final pathParts = rawPath.split('/');
    final classBaseName = _toPascalCase(pathParts.last);
    final folderPath = pathParts.length > 1
        ? pathParts.sublist(0, pathParts.length - 1).map(_toSnakeCase).join('/')
        : '';
    final snakeName = _toSnakeCase(pathParts.last);

    switch (command) {
      case 'make:controller':
        await _createController(folderPath, classBaseName, snakeName);
        break;
      case 'make:binding':
        await _createBinding(folderPath, classBaseName, snakeName, packageName);
        break;
      case 'make:screen':
        await _createScreen(folderPath, classBaseName, snakeName, packageName);
        break;
      case 'make:page':
        await _makePage(folderPath, classBaseName, snakeName, packageName);
        break;
      case 'make:service':
        await _createService(folderPath, classBaseName, snakeName, packageName);
        break;
      default:
        print('\x1B[31m‚ùå Unknown command: $command\x1B[0m');
        _showHelp();
    }
  }
}

Future<void> _initProject() async {
  final pubspec = File('pubspec.yaml');
  if (!pubspec.existsSync()) {
    print('\x1B[31m‚ùå Error: Not a Flutter project. pubspec.yaml not found.\x1B[0m');
    exit(1);
  }

  print('\x1B[36müöÄ Initializing Flutter project with GetX and Dio...\x1B[0m');

  // Install GetX and Dio
  await Process.run('dart', ['pub', 'add', 'get']);
  await Process.run('dart', ['pub', 'add', 'dio']);

  print('\x1B[32m‚úÖ Installed GetX and Dio.\x1B[0m');

  // Create folder structure
  final dirs = [
    'lib/config',
    'lib/controllers',
    'lib/bindings',
    'lib/models',
    'lib/screens',
    'lib/widgets',
  ];
  for (var dir in dirs) {
    await Directory(dir).create(recursive: true);
  }
  print('\x1B[32m‚úÖ Created recommended folder structure.\x1B[0m');

  // Create app_colors.dart with theme support
  final appColorsContent = '''
import 'package:flutter/material.dart';

class AppColors {
  // Light Theme Colors
  static const Color lightPrimary = Color(0xFF6366F1); // Modern indigo
  static const Color lightSecondary = Color(0xFF8B5CF6); // Purple
  static const Color lightAccent = Color(0xFF10B981); // Emerald
  static const Color lightBackground = Color(0xFFFAFAFA);
  static const Color lightSurface = Colors.white;
  static const Color lightOnPrimary = Colors.white;
  static const Color lightOnSecondary = Colors.white;
  static const Color lightOnBackground = Color(0xFF1F2937);
  static const Color lightOnSurface = Color(0xFF1F2937);
  
  // Dark Theme Colors
  static const Color darkPrimary = Color(0xFF818CF8); // Light indigo
  static const Color darkSecondary = Color(0xFFA78BFA); // Light purple  
  static const Color darkAccent = Color(0xFF34D399); // Light emerald
  static const Color darkBackground = Color(0xFF0F172A); // Dark slate
  static const Color darkSurface = Color(0xFF1E293B); // Medium slate
  static const Color darkOnPrimary = Color(0xFF0F172A);
  static const Color darkOnSecondary = Color(0xFF0F172A);
  static const Color darkOnBackground = Color(0xFFF8FAFC);
  static const Color darkOnSurface = Color(0xFFF8FAFC);

  // Legacy colors for backward compatibility
  static const Color primary = lightPrimary;
  static const Color accent = lightAccent;
  static const Color appBarColor = Colors.white;
  static const Color appBarBackground = lightPrimary;
}
''';
  await File('lib/config/app_colors.dart').writeAsString(appColorsContent);
  print('\x1B[32m‚úÖ Created lib/config/app_colors.dart\x1B[0m');

  // Create app_routes.dart
  final appRoutesContent = '''
import 'package:get/get.dart';

class AppRoutes {
  static final routes = <GetPage>[];
}
''';
  await File('lib/config/app_routes.dart').writeAsString(appRoutesContent);
  print('\x1B[32m‚úÖ Created lib/config/app_routes.dart\x1B[0m');

  // Create app_theme.dart
  final appThemeContent = '''
import 'package:flutter/material.dart';
import 'app_colors.dart';

class AppTheme {
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.light,
      primarySwatch: _createMaterialColor(AppColors.lightPrimary),
      primaryColor: AppColors.lightPrimary,
      colorScheme: const ColorScheme.light(
        primary: AppColors.lightPrimary,
        secondary: AppColors.lightSecondary,
        tertiary: AppColors.lightAccent,
        background: AppColors.lightBackground,
        surface: AppColors.lightSurface,
        onPrimary: AppColors.lightOnPrimary,
        onSecondary: AppColors.lightOnSecondary,
        onBackground: AppColors.lightOnBackground,
        onSurface: AppColors.lightOnSurface,
      ),
      scaffoldBackgroundColor: AppColors.lightBackground,
      appBarTheme: const AppBarTheme(
        backgroundColor: AppColors.lightPrimary,
        foregroundColor: AppColors.lightOnPrimary,
        elevation: 0,
        centerTitle: true,
      ),
      cardTheme: const CardTheme(
        color: AppColors.lightSurface,
        elevation: 2,
        margin: EdgeInsets.all(8),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppColors.lightPrimary,
          foregroundColor: AppColors.lightOnPrimary,
          elevation: 2,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: AppColors.lightPrimary),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: AppColors.lightPrimary, width: 2),
        ),
      ),
      fontFamily: 'Roboto',
    );
  }

  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      primarySwatch: _createMaterialColor(AppColors.darkPrimary),
      primaryColor: AppColors.darkPrimary,
      colorScheme: const ColorScheme.dark(
        primary: AppColors.darkPrimary,
        secondary: AppColors.darkSecondary,
        tertiary: AppColors.darkAccent,
        background: AppColors.darkBackground,
        surface: AppColors.darkSurface,
        onPrimary: AppColors.darkOnPrimary,
        onSecondary: AppColors.darkOnSecondary,
        onBackground: AppColors.darkOnBackground,
        onSurface: AppColors.darkOnSurface,
      ),
      scaffoldBackgroundColor: AppColors.darkBackground,
      appBarTheme: const AppBarTheme(
        backgroundColor: AppColors.darkSurface,
        foregroundColor: AppColors.darkOnSurface,
        elevation: 0,
        centerTitle: true,
      ),
      cardTheme: const CardTheme(
        color: AppColors.darkSurface,
        elevation: 4,
        margin: EdgeInsets.all(8),
      ),
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: AppColors.darkPrimary,
          foregroundColor: AppColors.darkOnPrimary,
          elevation: 2,
          padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(8),
          ),
        ),
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: AppColors.darkPrimary),
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(8),
          borderSide: const BorderSide(color: AppColors.darkPrimary, width: 2),
        ),
      ),
      fontFamily: 'Roboto',
    );
  }

  static MaterialColor _createMaterialColor(Color color) {
    List strengths = <double>[.05];
    final swatch = <int, Color>{};
    final int r = color.red, g = color.green, b = color.blue;

    for (int i = 1; i < 10; i++) {
      strengths.add(0.1 * i);
    }

    for (var strength in strengths) {
      final double ds = 0.5 - strength;
      swatch[(strength * 1000).round()] = Color.fromRGBO(
        r + ((ds < 0 ? r : (255 - r)) * ds).round(),
        g + ((ds < 0 ? g : (255 - g)) * ds).round(),
        b + ((ds < 0 ? b : (255 - b)) * ds).round(),
        1,
      );
    }

    return MaterialColor(color.value, swatch);
  }
}
''';
  await File('lib/config/app_theme.dart').writeAsString(appThemeContent);
  print('\x1B[32m‚úÖ Created lib/config/app_theme.dart\x1B[0m');

  // Create MainPage
  final mainPageContent = '''
import 'package:flutter/material.dart';
import 'package:get/get.dart';

class MainPage extends StatelessWidget {
  const MainPage({super.key});

  @override
  Widget build(BuildContext context) {
    final isDark = Theme.of(context).brightness == Brightness.dark;
    
    return Scaffold(
      appBar: AppBar(
        title: const Text('Welcome to Plumer'),
        actions: [
          IconButton(
            icon: Icon(isDark ? Icons.light_mode : Icons.dark_mode),
            onPressed: () {
              Get.changeThemeMode(
                isDark ? ThemeMode.light : ThemeMode.dark,
              );
            },
            tooltip: isDark ? 'Switch to Light Mode' : 'Switch to Dark Mode',
          ),
        ],
      ),
      body: Padding(
        padding: const EdgeInsets.all(24.0),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(
              Icons.flutter_dash,
              size: 80,
              color: Theme.of(context).colorScheme.primary,
            ),
            const SizedBox(height: 24),
            Text(
              'Plumer CLI',
              style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                fontWeight: FontWeight.bold,
                color: Theme.of(context).colorScheme.primary,
              ),
            ),
            const SizedBox(height: 16),
            Text(
              'Your Flutter project has been initialized successfully!',
              textAlign: TextAlign.center,
              style: Theme.of(context).textTheme.bodyLarge?.copyWith(
                color: Theme.of(context).colorScheme.onBackground,
              ),
            ),
            const SizedBox(height: 32),
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  children: [
                    Icon(
                      Icons.palette,
                      size: 40,
                      color: Theme.of(context).colorScheme.secondary,
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Theme Support',
                      style: Theme.of(context).textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Your app now supports both light and dark themes. Toggle between them using the button in the app bar!',
                      textAlign: TextAlign.center,
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 24),
            ElevatedButton.icon(
              onPressed: () {
                Get.snackbar(
                  'Welcome!',
                  'Start building your amazing Flutter app with Plumer CLI',
                  snackPosition: SnackPosition.BOTTOM,
                  backgroundColor: Theme.of(context).colorScheme.primary,
                  colorText: Theme.of(context).colorScheme.onPrimary,
                );
              },
              icon: const Icon(Icons.rocket_launch),
              label: const Text('Get Started'),
            ),
          ],
        ),
      ),
    );
  }
}
''';
  await File('lib/screens/main_page.dart').writeAsString(mainPageContent);
  print('\x1B[32m‚úÖ Created lib/screens/main_page.dart\x1B[0m');

  // Replace main.dart
  final mainDartContent = '''
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'config/app_theme.dart';
import 'config/app_routes.dart';
import 'screens/main_page.dart';

void main() {
  runApp(const PlumerApp());
}

class PlumerApp extends StatelessWidget {
  const PlumerApp({super.key});

  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Plumer App',
      theme: AppTheme.lightTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: ThemeMode.system, // Automatically switches based on system preference
      initialRoute: '/',
      getPages: [
        GetPage(name: '/', page: () => const MainPage()),
        ...AppRoutes.routes,
      ],
    );
  }
}
''';
  await File('lib/main.dart').writeAsString(mainDartContent);
  print('\x1B[32m‚úÖ Overwrote lib/main.dart with Plumer starter template.\x1B[0m');

  print('\x1B[36müéâ Plumer initialization complete! Run your app with:\n   flutter run\x1B[0m');
}

Future<void> _installWidget(String widgetName, String? customPath) async {
  print('\x1B[36müì¶ Installing widget: $widgetName\x1B[0m');
  
  // Determine the target folder
  final targetFolder = customPath ?? 'lib/widgets';
  
  // Create target directory if it doesn't exist
  final targetDir = Directory(targetFolder);
  if (!targetDir.existsSync()) {
    await targetDir.create(recursive: true);
    print('\x1B[32m‚úÖ Created directory: $targetFolder\x1B[0m');
  }
  
  // Construct the GitHub raw file URL
  final githubUrl = 'https://raw.githubusercontent.com/dennokorir/plumer/main/widgets/$widgetName.dart';
  final targetFile = File('$targetFolder/$widgetName.dart');
  
  // Check if file already exists
  if (targetFile.existsSync()) {
    print('\x1B[33m‚ö†Ô∏è  Widget $widgetName.dart already exists in $targetFolder\x1B[0m');
    print('Do you want to overwrite it? (y/N): ');
    final response = stdin.readLineSync()?.toLowerCase();
    if (response != 'y' && response != 'yes') {
      print('\x1B[36müìã Installation cancelled.\x1B[0m');
      return;
    }
  }
  
  try {
    print('\x1B[36m‚¨áÔ∏è  Downloading from GitHub...\x1B[0m');
    
    // Download the widget file from GitHub
    final result = await Process.run('curl', [
      '-s',
      '-f',
      '-L',
      githubUrl,
    ]);
    
    if (result.exitCode == 0 && result.stdout.toString().trim().isNotEmpty) {
      final widgetContent = result.stdout.toString();
      
      // Check if we got a valid Dart file (basic validation)
      if (!widgetContent.contains('class') || widgetContent.contains('404: Not Found')) {
        print('\x1B[31m‚ùå Widget "$widgetName" not found in the repository.\x1B[0m');
        print('Available widgets: slider, button, card, input, dialog');
        print('Or check: https://github.com/dennokorir/plumer/tree/main/widgets');
        return;
      }
      
      // Write the file
      await targetFile.writeAsString(widgetContent);
      
      print('\x1B[32m‚úÖ Successfully installed $widgetName.dart to $targetFolder\x1B[0m');
      
      // Show usage instructions
      print('\x1B[36müí° Usage instructions:\x1B[0m');
      print('   1. Import the widget in your screen/page:');
      print('      import \'package:your_app/$targetFolder/$widgetName.dart\';');
      print('   2. Use it in your widget tree:');
      print('      ${_toPascalCase(widgetName)}()');
      
    } else {
      print('\x1B[31m‚ùå Failed to download widget from GitHub.\x1B[0m');
      print('Error: ${result.stderr}');
      print('Please check your internet connection and try again.');
    }
    
  } catch (e) {
    print('\x1B[31m‚ùå Error downloading widget: $e\x1B[0m');
    print('Please ensure curl is installed and you have internet connectivity.');
  }
}

Future<void> _createService(String folder, String pascal, String snake, String packageName) async {
  final dir = 'lib/services${folder.isNotEmpty ? '/$folder' : ''}';
  final file = File('$dir/${snake}_service.dart');
  
  // Check if file already exists
  if (file.existsSync()) {
    print('\x1B[33m‚ö†Ô∏è  Service ${snake}_service.dart already exists in $dir\x1B[0m');
    print('Do you want to overwrite it? (y/N): ');
    final response = stdin.readLineSync()?.toLowerCase();
    if (response != 'y' && response != 'yes') {
      print('\x1B[36müìã Service creation cancelled.\x1B[0m');
      return;
    }
  }
  
  // Ensure required files exist
  await _ensureApiConfig(packageName);
  await _ensureBaseApiService(packageName);
  
  await file.create(recursive: true);
  final importPath = 'package:$packageName/config/api_endpoints.dart';
  final baseServiceImport = 'package:$packageName/services/base_api_service.dart';
  
  await file.writeAsString('''
import 'package:dio/dio.dart';
import 'package:get/get.dart';
import '$importPath';
import '$baseServiceImport';

/// ${pascal}Service - Handles all ${pascal.toLowerCase()} related API calls
/// 
/// Usage:
/// ```dart
/// final service = Get.find<${pascal}Service>();
/// final result = await service.get${pascal}List();
/// ```
class ${pascal}Service extends BaseApiService {
  static const String _baseEndpoint = '/${snake}';
  
  /// Get list of ${snake}s
  Future<Response> get${pascal}List({
    int? page,
    int? limit,
    Map<String, dynamic>? filters,
  }) async {
    try {
      final queryParams = <String, dynamic>{};
      
      if (page != null) queryParams['page'] = page;
      if (limit != null) queryParams['limit'] = limit;
      if (filters != null) queryParams.addAll(filters);
      
      logInfo('Fetching ${snake} list', data: queryParams);
      
      final response = await dio.get(
        ApiEndpoints.buildUrl(_baseEndpoint),
        queryParameters: queryParams.isEmpty ? null : queryParams,
      );
      
      logSuccess('Successfully fetched ${snake} list');
      return response;
      
    } catch (e) {
      logError('Failed to fetch ${snake} list', error: e);
      rethrow;
    }
  }
  
  /// Get ${snake} by ID
  Future<Response> get${pascal}ById(String id) async {
    try {
      logInfo('Fetching ${snake} with ID: \$id');
      
      final response = await dio.get(
        ApiEndpoints.buildUrl('\$_baseEndpoint/\$id'),
      );
      
      logSuccess('Successfully fetched ${snake} with ID: \$id');
      return response;
      
    } catch (e) {
      logError('Failed to fetch ${snake} with ID: \$id', error: e);
      rethrow;
    }
  }
  
  /// Create new ${snake}
  Future<Response> create${pascal}(Map<String, dynamic> data) async {
    try {
      logInfo('Creating new ${snake}', data: data);
      
      final response = await dio.post(
        ApiEndpoints.buildUrl(_baseEndpoint),
        data: data,
      );
      
      logSuccess('Successfully created ${snake}');
      return response;
      
    } catch (e) {
      logError('Failed to create ${snake}', error: e);
      rethrow;
    }
  }
  
  /// Update ${snake} by ID
  Future<Response> update${pascal}(String id, Map<String, dynamic> data) async {
    try {
      logInfo('Updating ${snake} with ID: \$id', data: data);
      
      final response = await dio.put(
        ApiEndpoints.buildUrl('\$_baseEndpoint/\$id'),
        data: data,
      );
      
      logSuccess('Successfully updated ${snake} with ID: \$id');
      return response;
      
    } catch (e) {
      logError('Failed to update ${snake} with ID: \$id', error: e);
      rethrow;
    }
  }
  
  /// Delete ${snake} by ID
  Future<Response> delete${pascal}(String id) async {
    try {
      logInfo('Deleting ${snake} with ID: \$id');
      
      final response = await dio.delete(
        ApiEndpoints.buildUrl('\$_baseEndpoint/\$id'),
      );
      
      logSuccess('Successfully deleted ${snake} with ID: \$id');
      return response;
      
    } catch (e) {
      logError('Failed to delete ${snake} with ID: \$id', error: e);
      rethrow;
    }
  }
  
  /// Upload file for ${snake}
  Future<Response> upload${pascal}File(String id, String filePath) async {
    try {
      logInfo('Uploading file for ${snake} with ID: \$id');
      
      final formData = FormData.fromMap({
        'file': await MultipartFile.fromFile(filePath),
        '${snake}_id': id,
      });
      
      final response = await dio.post(
        ApiEndpoints.buildUrl('\$_baseEndpoint/\$id/upload'),
        data: formData,
      );
      
      logSuccess('Successfully uploaded file for ${snake} with ID: \$id');
      return response;
      
    } catch (e) {
      logError('Failed to upload file for ${snake} with ID: \$id', error: e);
      rethrow;
    }
  }
  
  /// Search ${snake}s
  Future<Response> search${pascal}s(String query, {
    int? page,
    int? limit,
  }) async {
    try {
      final queryParams = <String, dynamic>{
        'q': query,
      };
      
      if (page != null) queryParams['page'] = page;
      if (limit != null) queryParams['limit'] = limit;
      
      logInfo('Searching ${snake}s with query: \$query');
      
      final response = await dio.get(
        ApiEndpoints.buildUrl('\$_baseEndpoint/search'),
        queryParameters: queryParams,
      );
      
      logSuccess('Successfully searched ${snake}s');
      return response;
      
    } catch (e) {
      logError('Failed to search ${snake}s', error: e);
      rethrow;
    }
  }
}
''');
  
  print('\x1B[32m‚úÖ Service created: ${file.path}\x1B[0m');
  
  // Show usage instructions
  print('\x1B[36müí° Usage instructions:\x1B[0m');
  print('   1. Register the service in your binding:');
  print('      Get.lazyPut<${pascal}Service>(() => ${pascal}Service());');
  print('   2. Use it in your controller:');
  print('      final service = Get.find<${pascal}Service>();');
  print('      final response = await service.get${pascal}List();');
}

Future<void> _ensureApiConfig(String packageName) async {
  final configFile = File('lib/config/api_endpoints.dart');
  if (!configFile.existsSync()) {
    await configFile.create(recursive: true);
    await configFile.writeAsString('''
/// API Endpoints Configuration
/// 
/// This file contains all API endpoints and configuration for your app.
/// Update the base URL and endpoints according to your backend API.
class ApiEndpoints {
  // Base Configuration
  static const String baseUrl = 'https://api.yourapp.com/v1';
  static const int connectTimeout = 30000; // 30 seconds
  static const int receiveTimeout = 30000; // 30 seconds
  static const int sendTimeout = 30000; // 30 seconds
  
  // Environment Configuration
  static bool get isDevelopment => const bool.fromEnvironment('DEBUG', defaultValue: true);
  static String get environment => isDevelopment ? 'development' : 'production';
  
  // API Versioning
  static const String apiVersion = 'v1';
  
  // Authentication Endpoints
  static const String login = '/auth/login';
  static const String register = '/auth/register';
  static const String refreshToken = '/auth/refresh';
  static const String logout = '/auth/logout';
  static const String forgotPassword = '/auth/forgot-password';
  static const String resetPassword = '/auth/reset-password';
  
  // User Endpoints
  static const String profile = '/user/profile';
  static const String updateProfile = '/user/profile';
  static const String changePassword = '/user/change-password';
  
  // Common Endpoints
  static const String upload = '/upload';
  static const String config = '/config';
  static const String health = '/health';
  
  // Utility Methods
  static String buildUrl(String endpoint) {
    if (endpoint.startsWith('http')) return endpoint;
    return '\$baseUrl\$endpoint';
  }
  
  static Map<String, String> get defaultHeaders => {
    'Content-Type': 'application/json',
    'Accept': 'application/json',
    'X-API-Version': apiVersion,
    'X-Platform': 'mobile',
  };
  
  // Development URLs (override for local development)
  static String get devBaseUrl => 'http://localhost:3000/api/v1';
  static String get currentBaseUrl => isDevelopment ? devBaseUrl : baseUrl;
}
''');
    print('\x1B[32m‚úÖ Created lib/config/api_endpoints.dart\x1B[0m');
  }
}

Future<void> _ensureBaseApiService(String packageName) async {
  final serviceFile = File('lib/services/base_api_service.dart');
  if (!serviceFile.existsSync()) {
    await serviceFile.create(recursive: true);
    await serviceFile.writeAsString('''
import 'package:dio/dio.dart';
import 'package:get/get.dart';
import 'package:flutter/foundation.dart';
import 'package:$packageName/config/api_endpoints.dart';

/// Base API Service with authentication and interceptors
/// 
/// All service classes should extend this base class to get:
/// - Automatic authentication headers
/// - Request/response logging
/// - Error handling
/// - Retry logic
abstract class BaseApiService extends GetxService {
  late Dio _dio;
  
  Dio get dio => _dio;
  
  // Observable auth token
  final RxString _authToken = ''.obs;
  String get authToken => _authToken.value;
  set authToken(String token) => _authToken.value = token;
  
  // Observable for network status
  final RxBool isConnected = true.obs;
  
  @override
  void onInit() {
    super.onInit();
    _initializeDio();
  }
  
  void _initializeDio() {
    _dio = Dio(BaseOptions(
      baseUrl: ApiEndpoints.currentBaseUrl,
      connectTimeout: const Duration(milliseconds: ApiEndpoints.connectTimeout),
      receiveTimeout: const Duration(milliseconds: ApiEndpoints.receiveTimeout),
      sendTimeout: const Duration(milliseconds: ApiEndpoints.sendTimeout),
      headers: ApiEndpoints.defaultHeaders,
    ));
    
    _addInterceptors();
  }
  
  void _addInterceptors() {
    // Auth Interceptor
    _dio.interceptors.add(InterceptorsWrapper(
      onRequest: (options, handler) {
        // Add auth token if available
        if (_authToken.value.isNotEmpty) {
          options.headers['Authorization'] = 'Bearer \${_authToken.value}';
        }
        
        // Add additional headers if needed
        options.headers.addAll(_getAdditionalHeaders());
        
        if (kDebugMode) {
          logInfo('üöÄ REQUEST[\${options.method}] => \${options.path}', 
            data: {
              'headers': options.headers,
              'queryParams': options.queryParameters,
              'data': options.data,
            }
          );
        }
        
        handler.next(options);
      },
      
      onResponse: (response, handler) {
        if (kDebugMode) {
          logSuccess('‚úÖ RESPONSE[\${response.statusCode}] => \${response.requestOptions.path}',
            data: response.data
          );
        }
        handler.next(response);
      },
      
      onError: (DioException error, handler) {
        _handleError(error);
        handler.next(error);
      },
    ));
    
    // Retry Interceptor
    _dio.interceptors.add(RetryInterceptor());
    
    // Logging Interceptor (only in debug mode)
    if (kDebugMode) {
      _dio.interceptors.add(LogInterceptor(
        requestBody: true,
        responseBody: true,
        requestHeader: true,
        responseHeader: false,
        logPrint: (obj) => logInfo(obj.toString()),
      ));
    }
  }
  
  Map<String, dynamic> _getAdditionalHeaders() {
    return {
      'X-Request-ID': DateTime.now().millisecondsSinceEpoch.toString(),
      'X-Client-Version': '1.0.0', // Update with your app version
    };
  }
  
  void _handleError(DioException error) {
    String errorMessage = 'An error occurred';
    
    switch (error.type) {
      case DioExceptionType.connectionTimeout:
      case DioExceptionType.sendTimeout:
      case DioExceptionType.receiveTimeout:
        errorMessage = 'Connection timeout. Please check your internet connection.';
        isConnected.value = false;
        break;
        
      case DioExceptionType.badResponse:
        final statusCode = error.response?.statusCode;
        switch (statusCode) {
          case 401:
            errorMessage = 'Unauthorized. Please login again.';
            _handleUnauthorized();
            break;
          case 403:
            errorMessage = 'Access forbidden.';
            break;
          case 404:
            errorMessage = 'Resource not found.';
            break;
          case 422:
            errorMessage = 'Validation error.';
            break;
          case 500:
            errorMessage = 'Server error. Please try again later.';
            break;
          default:
            errorMessage = error.response?.data?['message'] ?? 'Server error occurred.';
        }
        break;
        
      case DioExceptionType.cancel:
        errorMessage = 'Request was cancelled.';
        break;
        
      case DioExceptionType.unknown:
        errorMessage = 'No internet connection.';
        isConnected.value = false;
        break;
        
      default:
        errorMessage = 'An unexpected error occurred.';
    }
    
    logError('‚ùå API ERROR: \$errorMessage', error: error);
    
    // Show user-friendly error message
    if (Get.isSnackbarOpen == false) {
      Get.snackbar(
        'Error',
        errorMessage,
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Get.theme.colorScheme.error,
        colorText: Get.theme.colorScheme.onError,
      );
    }
  }
  
  void _handleUnauthorized() {
    // Clear auth token
    _authToken.value = '';
    
    // Navigate to login screen
    // Get.offAllNamed('/login'); // Uncomment and update route as needed
  }
  
  // Helper methods for consistent logging
  void logInfo(String message, {dynamic data}) {
    if (kDebugMode) {
      print('‚ÑπÔ∏è [API] \$message');
      if (data != null) print('   Data: \$data');
    }
  }
  
  void logSuccess(String message, {dynamic data}) {
    if (kDebugMode) {
      print('‚úÖ [API] \$message');
      if (data != null) print('   Data: \$data');
    }
  }
  
  void logError(String message, {dynamic error, dynamic data}) {
    if (kDebugMode) {
      print('‚ùå [API] \$message');
      if (error != null) print('   Error: \$error');
      if (data != null) print('   Data: \$data');
    }
  }
  
  // Utility methods
  void updateAuthToken(String token) {
    authToken = token;
  }
  
  void clearAuthToken() {
    authToken = '';
  }
  
  bool get isAuthenticated => authToken.isNotEmpty;
  
  // Override this in child classes for service-specific headers
  Map<String, String> getServiceHeaders() => {};
}

/// Retry Interceptor for handling temporary network failures
class RetryInterceptor extends Interceptor {
  static const int maxRetries = 3;
  static const Duration retryDelay = Duration(seconds: 1);
  
  @override
  void onError(DioException err, ErrorInterceptorHandler handler) async {
    if (_shouldRetry(err) && err.requestOptions.extra['retryCount'] != null) {
      final retryCount = (err.requestOptions.extra['retryCount'] as int?) ?? 0;
      
      if (retryCount < maxRetries) {
        err.requestOptions.extra['retryCount'] = retryCount + 1;
        
        // Wait before retry
        await Future.delayed(retryDelay * (retryCount + 1));
        
        try {
          final response = await Dio().fetch(err.requestOptions);
          handler.resolve(response);
          return;
        } catch (e) {
          // Continue to next retry or fail
        }
      }
    }
    
    handler.next(err);
  }
  
  bool _shouldRetry(DioException error) {
    return error.type == DioExceptionType.connectionTimeout ||
           error.type == DioExceptionType.receiveTimeout ||
           error.type == DioExceptionType.unknown ||
           (error.response?.statusCode != null && 
            error.response!.statusCode! >= 500);
  }
}
''');
    print('\x1B[32m‚úÖ Created lib/services/base_api_service.dart\x1B[0m');
  }
}

void _showHelp() {
  print('\x1B[36mü™∂ Plumer CLI - Available Commands:\x1B[0m');
  print('');
  print('\x1B[33mProject Setup:\x1B[0m');
  print('  init                     Initialize project with GetX, themes, and structure');
  print('');
  print('\x1B[33mCode Generation:\x1B[0m');
  print('  make:controller [path]   Generate a GetX controller');
  print('  make:binding [path]      Generate a GetX binding');
  print('  make:screen [path]       Generate a Flutter screen/page');
  print('  make:service [path]      Generate an API service with Dio integration');
  print('  make:page [path]         Generate complete page (controller + binding + screen + route)');
  print('');
  print('\x1B[33mWidget Installation:\x1B[0m');
  print('  install:widget [name]              Install widget to lib/widgets/');
  print('  install:widget [name] [folder]     Install widget to custom folder');
  print('');
  print('\x1B[33mExamples:\x1B[0m');
  print('  plumer init');
  print('  plumer make:page User/Profile');
  print('  plumer make:controller Auth/Login');
  print('  plumer make:service Api/User');
  print('  plumer install:widget slider');
  print('  plumer install:widget button lib/components');
  print('');
  print('\x1B[33mFor more information, visit:\x1B[0m https://github.com/dennokorir/plumer');
}

Future<bool> _isFlutterProject() async {
  final pubspec = File('pubspec.yaml');
  if (!pubspec.existsSync()) return false;
  final content = await pubspec.readAsString();
  return content.contains('flutter:');
}

Future<String> _getPackageName() async {
  final pubspec = File('pubspec.yaml');
  if (!pubspec.existsSync()) {
    print('\x1B[31m‚ùå pubspec.yaml not found. Exiting.\x1B[0m');
    exit(1);
  }
  final content = await pubspec.readAsLines();
  for (final line in content) {
    final trimmed = line.trim();
    if (trimmed.startsWith('name:')) {
      final name = trimmed.substring(5).trim();
      if (name.isNotEmpty) return name;
    }
  }
  print('\x1B[31m‚ùå Could not find project name in pubspec.yaml. Exiting.\x1B[0m');
  exit(1);
}

Future<void> _makePage(String folder, String pascal, String snake, String packageName) async {
  final controllerPath = 'lib/controllers${folder.isNotEmpty ? '/$folder' : ''}/${snake}_controller.dart';
  final bindingPath = 'lib/bindings${folder.isNotEmpty ? '/$folder' : ''}/${snake}_binding.dart';
  final screenPath = 'lib/screens${folder.isNotEmpty ? '/$folder' : ''}/${snake}_screen.dart';

  final routeName = "/${folder.isNotEmpty ? folder + '/' : ''}${snake}".replaceAll('_', '');
  final routeSignature = "GetPage(name: '$routeName',";

  final appRoutesFile = File('lib/config/app_routes.dart');
  if (!appRoutesFile.existsSync()) {
    print('\x1B[31m‚ùå lib/config/app_routes.dart not found. Cannot update routes.\x1B[0m');
    exit(1);
  }

  final appRoutesContent = await appRoutesFile.readAsString();

  final conflicts = <String>[];
  if (File(controllerPath).existsSync()) conflicts.add(controllerPath);
  if (File(bindingPath).existsSync()) conflicts.add(bindingPath);
  if (File(screenPath).existsSync()) conflicts.add(screenPath);
  if (appRoutesContent.contains(routeSignature)) conflicts.add('Route already exists in app_routes.dart');

  if (conflicts.isNotEmpty) {
    print('\x1B[31m‚ùå Cannot create page because the following already exist:\x1B[0m');
    for (final c in conflicts) {
      print(' - $c');
    }
    print('\x1B[31mAborting and reverting changes.\x1B[0m');
    exit(1);
  }

  await _createController(folder, pascal, snake);
  await _createBinding(folder, pascal, snake, packageName);
  await _createScreen(folder, pascal, snake, packageName);
  await _updateAppRoutes(folder, pascal, snake, packageName);

  print('\x1B[32m‚úÖ Page created and registered in routes for "$folder/$pascal".\x1B[0m');
}

Future<void> _createController(String folder, String pascal, String snake) async {
  final dir = 'lib/controllers${folder.isNotEmpty ? '/$folder' : ''}';
  final file = File('$dir/${snake}_controller.dart');
  await file.create(recursive: true);
  await file.writeAsString('''
import 'package:get/get.dart';

class ${pascal}Controller extends GetxController {

}
''');
  print('\x1B[32m‚úÖ Controller created: ${file.path}\x1B[0m');
}

Future<void> _createBinding(String folder, String pascal, String snake, String packageName) async {
  final dir = 'lib/bindings${folder.isNotEmpty ? '/$folder' : ''}';
  final file = File('$dir/${snake}_binding.dart');
  await file.create(recursive: true);
  final importPath = 'package:$packageName/controllers${folder.isNotEmpty ? '/$folder' : ''}/${snake}_controller.dart';
  await file.writeAsString('''
import 'package:get/get.dart';
import '$importPath';

class ${pascal}Binding extends Bindings {
  @override
  void dependencies() {
    Get.lazyPut<${pascal}Controller>(() => ${pascal}Controller());
  }
}
''');
  print('\x1B[32m‚úÖ Binding created: ${file.path}\x1B[0m');
}

Future<void> _createScreen(String folder, String pascal, String snake, String packageName) async {
  final dir = 'lib/screens${folder.isNotEmpty ? '/$folder' : ''}';
  final file = File('$dir/${snake}_screen.dart');
  await file.create(recursive: true);
  final importPath = 'package:$packageName/controllers${folder.isNotEmpty ? '/$folder' : ''}/${snake}_controller.dart';
  await file.writeAsString('''
import 'package:get/get.dart';
import 'package:flutter/material.dart';
import 'package:$packageName/config/app_colors.dart';
import '$importPath';

class ${pascal}Screen extends GetView<${pascal}Controller> {
  const ${pascal}Screen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('${_splitPascalCase(pascal)}'),
        backgroundColor: AppColors.appBarBackground,
        foregroundColor: AppColors.appBarColor,
      ),
      body: const Center(
        child: Text(
          '${_splitPascalCase(pascal)} Screen',
          style: TextStyle(color: AppColors.primary, fontSize: 24),
        ),
      ),
    );
  }
}
''');
  print('\x1B[32m‚úÖ Screen created: ${file.path}\x1B[0m');
}

Future<void> _updateAppRoutes(
  String folder,
  String pascal,
  String snake,
  String packageName,
) async {
  final appRoutesFile = File('lib/config/app_routes.dart');

  if (!appRoutesFile.existsSync()) {
    print('\x1B[31m‚ùå lib/config/app_routes.dart not found.\x1B[0m');
    exit(1);
  }

  var content = await appRoutesFile.readAsString();

  final importBinding =
      "import 'package:$packageName/bindings${folder.isNotEmpty ? '/$folder' : ''}/${snake}_binding.dart';";
  final importScreen =
      "import 'package:$packageName/screens${folder.isNotEmpty ? '/$folder' : ''}/${snake}_screen.dart';";

  final routeName =
      "/${folder.isNotEmpty ? folder + '/' : ''}${snake}".replaceAll('_', '');
  final pageRegistration =
      "GetPage(name: '$routeName', page: () => const ${pascal}Screen(), binding: ${pascal}Binding()),";

  // Insert imports at top if not present
  if (!content.contains(importBinding)) {
    // Put AFTER the last import OR at top
    final importRegex = RegExp(r"(import .+;)");
    final matches = importRegex.allMatches(content).toList();
    if (matches.isNotEmpty) {
      final lastImport = matches.last;
      content = content.replaceRange(
        lastImport.end,
        lastImport.end,
        '\n$importBinding',
      );
    } else {
      content = '$importBinding\n$content';
    }
  }

  if (!content.contains(importScreen)) {
    final importRegex = RegExp(r"(import .+;)");
    final matches = importRegex.allMatches(content).toList();
    if (matches.isNotEmpty) {
      final lastImport = matches.last;
      content = content.replaceRange(
        lastImport.end,
        lastImport.end,
        '\n$importScreen',
      );
    } else {
      content = '$importScreen\n$content';
    }
  }

  // Flexible route list regex for [] or <GetPage>[]
  final routesRegex =
      RegExp(r'static final routes\s*=\s*(<GetPage>)?\[(.*?)\];', dotAll: true);
  final match = routesRegex.firstMatch(content);

  if (match != null) {
    final currentRoutes = match.group(2)?.trim() ?? '';
    final updatedRoutes = (currentRoutes.isEmpty)
        ? '  $pageRegistration'
        : '$currentRoutes\n    $pageRegistration';

    final newRoutes = match.group(1) != null
        ? 'static final routes = <GetPage>[\n$updatedRoutes\n  ];'
        : 'static final routes = [\n$updatedRoutes\n  ];';

    content = content.replaceFirst(routesRegex, newRoutes);

    await appRoutesFile.writeAsString(content);
    print(
        '\x1B[32m‚úÖ Route for "$routeName" added to lib/config/app_routes.dart\x1B[0m');
  } else {
    print(
        '\x1B[31m‚ùå Could not locate routes list in app_routes.dart. Please ensure it uses: static final routes = []; or static final routes = <GetPage>[];\x1B[0m');
    exit(1);
  }
}

String _toSnakeCase(String input) {
  return input.replaceAllMapped(
      RegExp(r'([a-z0-9])([A-Z])'), (Match m) => '${m[1]}_${m[2]}').toLowerCase();
}

String _toPascalCase(String input) {
  return input
      .split(RegExp(r'[_\-\s]'))
      .where((part) => part.isNotEmpty)
      .map((part) => part[0].toUpperCase() + part.substring(1))
      .join();
}

String _splitPascalCase(String input) {
  return input.replaceAllMapped(RegExp(r'([a-z])([A-Z])'), (m) => '${m[1]} ${m[2]}');
}


